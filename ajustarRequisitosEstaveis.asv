function [requisitos_corrigido, J_min] = ajustarRequisitosEstaveis(xr, requisitos)
% Ajusta Mp e tr para estabilizar e aproximar dos desejados usando Nelder-Mead
% com recuos progressivos caso o sistema continue instável

    max_tentativas = 10;

    Mp_req = requisitos.x.Mp;
    tr_req = requisitos.x.tr;

    for tentativa = 1:max_tentativas
        fprintf("Tentativa = %d\n", tentativa);
        x0 = [Mp_req, tr_req];

        custo = @(x) custo_penalizado(x, xr, requisitos);

        % Otimização Nelder-Mead
        [x_opt, J_min] = fminsearch(custo, x0);

        % Se encontrou solução viável, sai do loop
        if J_min < 1e6
            break;
        end

        % Caso contrário, aumenta tr
        tr_req = tr_req * 2;

    end

    % Retornar requisitos corrigidos
    requisitos_corrigido = requisitos;
    requisitos_corrigido.x.Mp = min(max(x_opt(1), 0.01), 1.0);
    requisitos_corrigido.x.tr = max(x_opt(2), 0.01);
end

function J = custo_penalizado(x, xr, requisitos)
    Mp = x(1);
    tr = x(2);

    % Restrições: positivos e Mp <= 1
    if Mp <= 0 || Mp > 1 || tr <= 0
        J = 1e6;
        return;
    end

    % Atualiza requisitos
    reqNovo = requisitos;
    reqNovo.x.Mp = Mp;
    reqNovo.x.tr = tr;

    sim = simularRampa(xr, reqNovo, false);
    estados = sim.x.signals.values;
    excesso = max(abs(estados), [], 'all');

    % Critério de instabilidade relativo a xr
    if excesso > 100 * xr
        J = 1e6;
    else
        % Custo quadrático em relação aos requisitos desejados
        J = (requisitos.x.Mp - reqNovo.Mp)^2 + (requisitos.x.tr - reqNtr)^2;
    end
end
